#!/usr/bin/env escript
%% -*- erlang -*-
%%! -name installation_script -pa ebin include
%% -mode(compile).
%% -compile(native).
-define(KAZOO_DEPS, ["wget", "build-essential"
                    ,"libxslt-dev", "zip" 
                    ,"unzip", "expat" 
                    ,"zlib1g-dev", "libssl-dev"
                    ,"curl", "libncurses5-dev"
                    ,"git-core", "libexpat1-dev"
                    ,"htmldoc", "erlang-18.3"]).
-define(COMMANDS, ["curl -o /etc/yum.repos.d/2600hz.repo http://repo.2600hz.com/2600hz.repo -s" %add 2600 repo
                  ,"yum -y install epel-release" %add epel repo
                  ,"curl -o /etc/yum.repos.d/erlang_solutions.repo http://packages.erlang-solutions.com/rpm/centos/erlang_solutions.repo" %add erlang_solutions repo
                  ,"yum -y install " ++ lists:flatten(lists:join(" ", ?KAZOO_DEPS)) %install deps
                  ,"git clone https://github.com/2600Hz/kazoo.git /opt/kazoo "++
                       "&& cd /opt/kazoo && git checkout 4.0 && make" %clone & make kazoo
                  ,"service iptables save && service iptables stop && chkconfig iptables off " ++
                       "&& sed -i 's/^SELINUX=.*$/SELINUX=disabled/g' /etc/selinux/config" %disable firewall and SELinux
                  ,"ln -s /opt/kazoo/core/sup/priv/sup /usr/bin/sup" %sup
                  ,"echo kazoo.nikitakz.local > /etc/localhost"      %FQDN (FIXME
                  ,"echo '127.0.0.1	kazoo.nikitakz.siplabs' >> /etc/localhost"      %FQDN (FIXME)
]).

%% INPUT POINT %%
main(_String) ->
    ssh:start(),
    {ok, ConnectionRef} = ssh:connect("192.168.0.75", 22, [{user, "root"}, {password, "a1s2d3!@#"}, {silently_accept_hosts, 'true'}]),
    lists:foreach(fun (Cmd)-> 
                          {0, _} = ssh_call(ConnectionRef, Cmd, infinity, [{'verbose', 'true'}])
                  end, ?COMMANDS),
    halt(0).

-spec parse_args(list()) -> tuple().
-spec parse_args(list(), tuple()) -> tuple().
parse_args(Args) when length(Args) rem 2 == 0 ->
    parse_args(Args, dict:new());
parse_args(_) ->
    erlang:error("Arguments count are odd.").
parse_args([], Acc) -> Acc;
parse_args([["-" | Key], Val | Tail], Acc)->
    parse_args(Tail, dict:append(Key, Val, Acc)).

%% =======================================
%% ---------- SSH functions --------------
%% =======================================
ssh_cast(ConnectionRef, Command)->
    {'ok', ChannelId} = ssh_connection:session_channel(ConnectionRef, infinity),
    'success' = ssh_connection:exec(ConnectionRef, ChannelId, Command, infinity). %leaks

ssh_call(ConnectionRef, Command, Timeout)->
    ssh_call(ConnectionRef, Command, Timeout, []).
ssh_call(ConnectionRef, Command, Timeout, Options)->
    IsVerbose = proplists:get_bool('verbose', Options),
    if IsVerbose -> io:format("Try execute " ++  normalize(Command) ++ "....");
        true -> 'ok'
    end,
    {'ok', ChannelId} = ssh_connection:session_channel(ConnectionRef, Timeout),
    'success' = ssh_connection:exec(ConnectionRef, ChannelId, Command, Timeout),
    {ExitCode, Responce} = wait_for_response(ConnectionRef, ChannelId, {0, []}),
    if IsVerbose -> case ExitCode of
                        0 -> io:format("done~n");
                        _ -> io:format("error~nexit code: ~p~nResponse:~p~n", [ExitCode, Responce])
                    end;
       true -> 'ok'
    end,
    {ExitCode, Responce}.
    
wait_for_response(ConnectionRef, ChannelId, Acc) ->
    receive
        {ssh_cm, ConnectionRef, Msg} ->
            case Msg of
                {closed, _ChannelId} -> Acc;
                {data, ChannelId, _DataCode, Data}->
                    NewAcc = setelement(2, Acc, element(2, Acc) ++ [Data]),
                    wait_for_response(ConnectionRef, ChannelId, NewAcc);
                {exit_status, _ChannelId, ExitStatus}->
                    NewAcc = setelement(1, Acc, ExitStatus),
                    wait_for_response(ConnectionRef, ChannelId, NewAcc);
                _ -> 
                    wait_for_response(ConnectionRef, ChannelId, Acc)
            end
    end.

normalize(Str)->
    normalizeStrWith(80, ".", Str).

normalizeStrWith(Length, Fill, Str) when length(Str) > Length ->
    Mid = Length div 2,
    A = lists:sublist(Str, Mid - 2),
    B = lists:sublist(lists:reverse(Str), Mid - 2),
    normalizeStrWith(Mid, Fill, A) ++ lists:reverse(normalizeStrWith(Mid, Fill, B));
normalizeStrWith(Length, Fill, Str) ->
    Str ++ lists:flatten(lists:duplicate(Length - length(Str),["."])).
